
\begin{DoxyItemize}
\item \mbox{\hyperlink{algorithm}{Algorithm Overview}}
\item \mbox{\hyperlink{sparse_example_usage}{Example Usage}}
\end{DoxyItemize}

This section gives an overview on the basic usage of the sparse solvers in STRUMPACK. Many STRUMPACK options can be set from the command line. Running with -\/-\/help or -\/h, will give you a list of supported run-\/time options.

An example Makefile is available in the examples/ directory. This is a simple manual Makefile, with certain variables set during the {\bfseries{CMake}} configure phase, see \mbox{\hyperlink{installation}{Installation and Requirements}}.

STRUMPACK is written in C++, and offers a simple C++ interface. See \mbox{\hyperlink{C_Interface}{C Interface }} if you prefer a C interface. The STRUMPACK sparse solver has three different solver classes, all interaction happens through objects of these classes\+:


\begin{DoxyItemize}
\item \mbox{\hyperlink{}{Strumpack\+Sparse\+Solver\texorpdfstring{$<$}{<}scalar,integer=int\texorpdfstring{$>$}{>}}} This class represents the sparse solver for a single computational node, optionally using Open\+MP parallelism. Use this if you are running the code sequentially, on a (multicore) laptop or desktop or on a single node of a larger cluster. This class is defined in Strumpack\+Sparse\+Solver.\+hpp, so include this header if you intend to use it.
\item \mbox{\hyperlink{}{Strumpack\+Sparse\+Solver\+MPIDist\texorpdfstring{$<$}{<}scalar,integer=int\texorpdfstring{$>$}{>}}} This solver is fully distributed. The numerical factorization and solve as well as the symbolic factorization are distributed. The input is now a block-\/row distributed sparse matrix and a correspondingly distributed right-\/hand side. For matrix reordering, Par\+Metis or PT-\/\+Scotch are used. Include the header file Strumpack\+Sparse\+Solver\+MPIDist.\+hpp and call MPI\+\_\+\+Init\mbox{[}\+\_\+thread\mbox{]}.
\end{DoxyItemize}

The three solver classes \mbox{\hyperlink{}{Strumpack\+Sparse\+Solver}}, \mbox{\hyperlink{}{Strumpack\+Sparse\+Solver\+MPI}} and \mbox{\hyperlink{}{Strumpack\+Sparse\+Solver\+MPIDist}} depend on two template parameters \texorpdfstring{$<$}{<}scalar,integer\texorpdfstring{$>$}{>}\+: the type of a scalar and an integer type. The scalar type can be float, double, std\+::complex$<$float$>$ or std\+::complex$<$double$>$. It is recommended to first try to simply use the default integer=int type, unless you run into 32 bit integer overflow problems. In that case one can switch to for instance int64\+\_\+t (a signed integer type).

\DoxyHorRuler{0}
 \hypertarget{algorithm}{}\doxysection{Algorithm}\label{algorithm}
The algorithm used in STRUMPACK is described in detail in \mbox{\hyperlink{References}{\mbox{[}5\mbox{]}}}, and is based on the work by Jianlin Xia \mbox{\hyperlink{References}{\mbox{[}9\mbox{]}}}. Here we summarize the main algorithm features. \mbox{\hyperlink{HSS_Preconditioning}{HSS Preconditioning}} has more information on the low-\/rank compression strategy and how to tune this to get a good preconditioner for your specific problem. There are three main steps in the algorithm\+: matrix reordering, factorization and solve.

\begin{DoxyParagraph}{Matrix reordering\+: }
There are three distinct matrix reordering steps\+: one for stability, one to limit fill-\/ in and one to reduce HSS-\/ranks. First, the matrix is reordered and possibly scaled for numerical stability by the MC64 code \mbox{\hyperlink{References}{\mbox{[}3\mbox{]}}} or by a code from Combinatorial BLAS \mbox{\hyperlink{References}{\mbox{[}1\mbox{]}}}. This step is called the matching phase. For many matrices, this reordering can safely be disabled. By default, MC64 is used to maximize the product of the diagonal values of the matrix, and to scale the rows and columns of the matrix. Alternatively, MC64 can be used to maximize the smallest diagonal value or to maximize the sum of the diagonals. Next, a nested dissection reordering is applied to limit fill-\/in. Both (Par)Metis and (PT-\/)Scotch are supported. We expose one user tunable parameter which controls the size of the smallest separators. Finally, when HSS compression is used, there is an extra reordering step to reduce the HSS-\/ranks. This reordering uses Metis and does not require user tuning.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Factorization\+: }
Before the actual numerical factorization, there is a symbolic factorization step to construct the elimination tree. After that, the multifrontal factorization procedure traverses this elimination tree from bottom (smallest separators) to top (root separator). With each node of the elimination tree a dense matrix is associated, referred to as a frontal matrix, or simply front. These fronts can possibly be compressed as Hierarchically Semi-\/\+Separable (HSS) matrices. This compression will only pay off for fronts that are large enough, which are typically the frontal matrices at the nodes in the elimination tree close to the root. Without any HSS compression, the solver acts as a standard multifrontal direct solver. HSS approximations are constructed using a randomized sampling algorithm.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Solve\+: }
Once the matrix is factorized, the factors can be used to efficiently solve a linear system of equations by doing a forward and a backward solve sweeps. When no HSS compression is used, this is a direct solver. The multifrontal solve procedure is then used within an iterative refinement loop, with typically only 1 or very few iterations. However, when the factors are compressed using HSS, a single multifrontal solve is only approximate and the solve is by default used as a preconditioner for GMRES(30). The required number of GMRES iterations will depend strongly on the quality of the HSS approximation. 
\end{DoxyParagraph}
\hypertarget{sparse_example_usage}{}\doxysection{Example Usage}\label{sparse_example_usage}
\hypertarget{sparse_example_usage_autotoc_md9}{}\doxysubsection{Strumpack\+Sparse\+Solver Example}\label{sparse_example_usage_autotoc_md9}
The following shows the typical way to use a (sequential or multithreaded) STRUMPACK sparse solver\+:



{\bfseries{Figure 1}}\+: Illustration of a small 5 × 5 sparse matrix with 11 nonzeros and its Compressed Sparse Row (CSR) or Yale format representation. We always use 0-\/based indexing! Let $N$ = 5 denote the number of rows. The row\+\_\+ptr array has $N$ +1 elements, with element $i$ denoting the start of row $i$ in the col\+\_\+ind and values arrays. Element row\+\_\+ptr\mbox{[}N\mbox{]} = nnz, i.\+e., the total number of nonzero elements in the matrix. The values array holds the actual matrix values, ordered by row. The corresponding elements in col\+\_\+ind give the column indices for each nonzero. There can be explicit zero elements in the matrix. The nonzero values and corresponding column indices need not be sorted by column (within a row).


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}StrumpackSparseSolver.hpp"{}}}
\DoxyCodeLine{\textcolor{keyword}{using namespace }strumpack;      \textcolor{comment}{// all strumpack code is in the strumpack namespace,}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) \{}
\DoxyCodeLine{   \textcolor{keywordtype}{int} N = ...;                      \textcolor{comment}{// construct an NxN CSR matrix with nnz nonzeros}}
\DoxyCodeLine{   \textcolor{keywordtype}{int}* row\_ptr = ...;               \textcolor{comment}{// N+1 integers}}
\DoxyCodeLine{   \textcolor{keywordtype}{int}* col\_ind = ...;               \textcolor{comment}{// nnz integers}}
\DoxyCodeLine{   \textcolor{keywordtype}{double}* val = ...;                \textcolor{comment}{// nnz scalars}}
\DoxyCodeLine{   \textcolor{keywordtype}{double}* x = \textcolor{keyword}{new} \textcolor{keywordtype}{double}[N];        \textcolor{comment}{// will hold the solution vector}}
\DoxyCodeLine{   \textcolor{keywordtype}{double}* b = ...;                  \textcolor{comment}{// set a right-\/hand side b}}
\DoxyCodeLine{}
\DoxyCodeLine{   StrumpackSparseSolver<double> sp;                   \textcolor{comment}{// create solver object}}
\DoxyCodeLine{   sp.options().set\_rel\_tol(1e-\/10);                    \textcolor{comment}{// set options}}
\DoxyCodeLine{   sp.options().set\_gmres\_restart(10);                 \textcolor{comment}{// ...}}
\DoxyCodeLine{   sp.options().set\_compression(CompressionType::HSS); \textcolor{comment}{// enable HSS compression, see HSS Preconditioning}}
\DoxyCodeLine{   sp.options().set\_from\_command\_line(argc, argv);     \textcolor{comment}{// parse command line options}}
\DoxyCodeLine{   sp.set\_csr\_matrix(N, row\_ptr, col\_ind, val);        \textcolor{comment}{// set the matrix (copy)}}
\DoxyCodeLine{   sp.reorder();                                       \textcolor{comment}{// reorder matrix}}
\DoxyCodeLine{   sp.factor();                                        \textcolor{comment}{// numerical factorization}}
\DoxyCodeLine{   sp.solve(b, x);                                     \textcolor{comment}{// solve Ax=b}}
\DoxyCodeLine{   ... \textcolor{comment}{// check residual/error and cleanup}}
\DoxyCodeLine{\}}

\end{DoxyCode}


The main steps are\+: create solver object, set options (parse options from the command line), set matrix, reorder, factor and finally solve. The matrix should be in the Compressed Sparse Row (CSR) format, also called Yale format, with 0 based indices. Figure 1 illustrates the CSR format. In the basic scenario, it is not necessary to explicitly call reorder and factor, since trying to solve with a Strumpack\+Sparse\+Solver object that is not factored yet, will internally call the factor routine, which will call reorder if necessary.

The above code should be linked with -\/lstrumpack and with the Metis, Par\+Metis, Scotch, PT-\/\+Scotch, BLAS, LAPACK, and Sca\+LAPACK libraries.\hypertarget{sparse_example_usage_autotoc_md11}{}\doxysubsection{Strumpack\+Sparse\+Solver\+MPIDist Example}\label{sparse_example_usage_autotoc_md11}
Finally, we illustrate the usage of \mbox{\hyperlink{}{Strumpack\+Sparse\+Solver\+MPIDist\texorpdfstring{$<$}{<}scalar,integer=int\texorpdfstring{$>$}{>} }} solver. This interface takes a block-\/row distributed compressed sparse row matrix as input. This matrix format is illustrated in Figure 2 (below).


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{ \#include "{}StrumpackSparseSolverMPI.hpp"{}}}
\DoxyCodeLine{ \textcolor{keyword}{using namespace }strumpack;}
\DoxyCodeLine{}
\DoxyCodeLine{ \textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[ ]) \{}
\DoxyCodeLine{     \textcolor{keywordtype}{int} thread\_level, rank, P;}
\DoxyCodeLine{     MPI\_Init\_thread(\&argc, \&argv, MPI\_THREAD\_FUNNELED, \&thread\_level);}
\DoxyCodeLine{     MPI\_Comm\_rank(MPI\_COMM\_WORLD, \&rank);}
\DoxyCodeLine{     MPI\_Comm\_size(MPI\_COMM\_WORLD, \&P);}
\DoxyCodeLine{     \{}
\DoxyCodeLine{         \textcolor{comment}{// define a block-\/row distributed CSR matrix}}
\DoxyCodeLine{         \textcolor{keywordtype}{int}* dist = \textcolor{keyword}{new} \textcolor{keywordtype}{int}[P];}
\DoxyCodeLine{         \textcolor{comment}{// set dist such that processor p owns rows [dist[p], dist[p+1]) of the sparse matrix}}
\DoxyCodeLine{         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} p=0; p<P; p++) dist[p] = .. ;}
\DoxyCodeLine{         \textcolor{comment}{// local\_n is the number of rows of the input matrix assigned to me}}
\DoxyCodeLine{         \textcolor{keywordtype}{int} local\_n   = dist[rank+1] -\/ dist[rank];}
\DoxyCodeLine{         \textcolor{keywordtype}{int}* row\_ptr  = \textcolor{keyword}{new} \textcolor{keywordtype}{int}[local\_n+1];}
\DoxyCodeLine{         .. \textcolor{comment}{// set the sparse matrix row pointers in row\_ptr}}
\DoxyCodeLine{         \textcolor{keywordtype}{int} local\_nnz = row\_ptr[local\_n+1] -\/ row\_ptr[0];}
\DoxyCodeLine{         \textcolor{keywordtype}{int}* col\_ind  = \textcolor{keyword}{new} \textcolor{keywordtype}{int}[local\_nnz];}
\DoxyCodeLine{         .. \textcolor{comment}{// set the sparse matrix column indices in col\_ind}}
\DoxyCodeLine{         \textcolor{keywordtype}{double}* val   = \textcolor{keyword}{new} \textcolor{keywordtype}{double}[local\_nnz];}
\DoxyCodeLine{         .. \textcolor{comment}{// set the matrix nonzero value in val}}
\DoxyCodeLine{         \textcolor{keywordtype}{double}* x = \textcolor{keyword}{new} \textcolor{keywordtype}{double}[local\_n];             \textcolor{comment}{// local part of solution}}
\DoxyCodeLine{         \textcolor{keywordtype}{double}* b = \textcolor{keyword}{new} \textcolor{keywordtype}{double}[local\_n];             \textcolor{comment}{// local part of rhs}}
\DoxyCodeLine{         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<local\_n; i++) b[i] = ..;     \textcolor{comment}{// set the rhs}}
\DoxyCodeLine{}
\DoxyCodeLine{         strumpack::StrumpackSparseSolverMPIDist<double> sp(MPI\_COMM\_WORLD);}
\DoxyCodeLine{         sp.options().set\_reordering\_method(ReorderingStrategy::PARMETIS);}
\DoxyCodeLine{         sp.options().set\_from\_command\_line(argc, argv);}
\DoxyCodeLine{         sp.set\_distributed\_csr\_matrix(local\_n, row\_ptr, col\_ind, val, dist);}
\DoxyCodeLine{         sp.solve(b, x);}
\DoxyCodeLine{         ... \textcolor{comment}{// check residual/error, cleanup}}
\DoxyCodeLine{     \}}
\DoxyCodeLine{     Cblacs\_exit(1);}
\DoxyCodeLine{     MPI\_Finalize();}
\DoxyCodeLine{\}}

\end{DoxyCode}




{\bfseries{Figure 2}}\+: Illustration of a small 5×5 sparse matrix with 11 nonzeros and its block-\/row distributed compressed sparse row representation. We always use 0-\/based indexing! Process P0 owns row 0, process P1 has rows 1 and 2 and process P2 has rows 3 and 4. This distribution of rows over the processes is represented by the dist array. Process p owns rows \mbox{[}dist\mbox{[}p\mbox{]},dist\mbox{[}p+1\mbox{]}). If N = 5 is the number of rows in the entire matrix and P is the total number of processes, then dist\mbox{[}P\mbox{]}=N. The (same) dist array is stored on every process. Each process holds a CSR representation of only its local rows of the matrix, see Figure 1.\hypertarget{sparse_example_usage_autotoc_md12}{}\doxysubsection{Initializing the Solver Object}\label{sparse_example_usage_autotoc_md12}
Let


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} strumpack::StrumpackSparseSolver<scalar,integer> Sp;}
\DoxyCodeLine{\textcolor{keyword}{typedef} strumpack::StrumpackSparseSolverMPI<scalar,integer> SpMPI;}
\DoxyCodeLine{\textcolor{keyword}{typedef} strumpack::StrumpackSparseSolverMPIDist<scalar,integer> SpMPIDist;}

\end{DoxyCode}


Each of the solver classes has two constructors\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{strumpack::StrumpackSparseSolver(\textcolor{keywordtype}{bool} verbose=\textcolor{keyword}{true}, \textcolor{keywordtype}{bool} root=\textcolor{keyword}{true});}
\DoxyCodeLine{strumpack::StrumpackSparseSolver(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[], \textcolor{keywordtype}{bool} verbose=\textcolor{keyword}{true}, \textcolor{keywordtype}{bool} root=\textcolor{keyword}{true});}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{strumpack::StrumpackSparseSolverMPIDist(MPI\_Comm comm, \textcolor{keywordtype}{bool} verbose=\textcolor{keyword}{true});}
\DoxyCodeLine{strumpack::StrumpackSparseSolverMPIDist(MPI\_Comm comm, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[], \textcolor{keywordtype}{bool} verbose=\textcolor{keyword}{true});}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{strumpack::StrumpackSparseSolverMPIDist(MPI\_Comm comm, \textcolor{keywordtype}{bool} verbose=\textcolor{keyword}{true});}
\DoxyCodeLine{strumpack::StrumpackSparseSolverMPIDist(MPI\_Comm comm, \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[], \textcolor{keywordtype}{bool} verbose=\textcolor{keyword}{true}); }

\end{DoxyCode}


where argc and argv contain the command line options and the verbose option can be set to false to suppress output of the solver. Note that since \mbox{\hyperlink{}{Sp\+MPIDist}} is a subclass of \mbox{\hyperlink{}{Sp\+MPI}}, which is a subclass of \mbox{\hyperlink{}{Sp}}, all public members of \mbox{\hyperlink{}{Sp}} are also members of \mbox{\hyperlink{}{Sp\+MPI}} and \mbox{\hyperlink{}{Sp\+MPIDist}}. The public interface to the \mbox{\hyperlink{}{Sp\+MPI}} class is exactly the same as that for the \mbox{\hyperlink{}{Sp}} class.\hypertarget{sparse_example_usage_autotoc_md13}{}\doxysubsection{Sparse Matrix Format}\label{sparse_example_usage_autotoc_md13}
The sparse matrix should be specified in compressed sparse row format \mbox{[}8\mbox{]}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} strumpack::StrumpackSparseSolver::set\_csr\_matrix(\textcolor{keywordtype}{int} N, \textcolor{keywordtype}{int}* row\_ptr, \textcolor{keywordtype}{int}* col\_ind, scalar* values, \textcolor{keywordtype}{bool} symmetric\_pattern=\textcolor{keyword}{false});}

\end{DoxyCode}


Internally, the matrix is copied, so it will not be modified. Previous versions of STRUMPACK also supported the CSC format, but this is now deprecated. If the sparsity pattern of the matrix is symmetric (the values do not have to be symmetric), then you can set symmetric\+\_\+pattern=true. This saves some work in the setup phase of the solver.

For the \mbox{\hyperlink{}{Sp\+MPIDist}} solver the input is a block-\/row distributed compressed sparse row matrix (as illustrated in the example above)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} strumpack::StrumpackSparseSolverMPIDist::set\_distributed\_csr\_matrix (integer local\_rows, integer* row\_ptr, integer* col\_ind, scalar* values, integer* dist, \textcolor{keywordtype}{bool} symmetric\_pattern=\textcolor{keyword}{false});}

\end{DoxyCode}


Alternatively, you can also specify a sequential CSR matrix to the \mbox{\hyperlink{}{Sp\+MPIDist}} solver\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} strumpack::StrumpackSparseSolverMPIDist::set\_csr\_matrix (integer N, integer* row\_ptr, integer* col\_ind, scalar* values, \textcolor{keywordtype}{bool} symmetric\_pattern=\textcolor{keyword}{false});}

\end{DoxyCode}


For this routine, the matrix only needs to be specified completely on the root process. Other processes can pass NULL for the arrays.\hypertarget{sparse_example_usage_autotoc_md14}{}\doxysubsection{Factorization}\label{sparse_example_usage_autotoc_md14}
Compute the factorization by calling


\begin{DoxyCode}{0}
\DoxyCodeLine{ReturnCode strumpack::StrumpackSparseSolver::factor();}

\end{DoxyCode}


where the possible return values are the same as for \mbox{\hyperlink{}{Sp\+::reorder()}}. If \mbox{\hyperlink{}{Sp\+::reorder() }} was not called already, it is called automatically. When compression is not enabled, this will compute an exact LU factorization of the (permuted) sparse input matrix. If HSS/\+HODLR/\+BLR compression is enabled (for instance with \mbox{\hyperlink{}{SPOptions\+::set\+\_\+compression()}} or -\/-\/sp\+\_\+compression BLR, see \mbox{\hyperlink{prec}{Preconditioning Preconditioning}}), the factorization is only approximate.\hypertarget{sparse_example_usage_autotoc_md15}{}\doxysubsection{Solve}\label{sparse_example_usage_autotoc_md15}
Solve the linear system $Ax = b$ by calling


\begin{DoxyCode}{0}
\DoxyCodeLine{ReturnCode strumpack::StrumpackSparseSolver::solve(scalar* b, scalar* x, \textcolor{keywordtype}{bool} use\_initial\_guess=\textcolor{keyword}{false});}

\end{DoxyCode}


By default (bool use\+\_\+initial\+\_\+guess=false) the input in x is ignored. If bool use\+\_\+initial\+\_\+guess=true, x is used as initial guess for the iterative solver (if an iterative solver is used, for instance iterative refinement or GMRES). If the \mbox{\hyperlink{}{Sp\+::factor()}} was not called, it is called automatically. The return values are the same as for \mbox{\hyperlink{}{Sp\+::reorder()}}.

The iterative solver can be chosen through\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} strumpack::SPOptions::set\_Krylov\_solver(strumpack::KrylovSolver s);}

\end{DoxyCode}


where \mbox{\hyperlink{}{Krylov\+Solver}} can take the following values\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{enum class} KrylovSolver \{}
\DoxyCodeLine{    AUTO,              }
\DoxyCodeLine{    DIRECT,            }
\DoxyCodeLine{    REFINE,            }
\DoxyCodeLine{    PREC\_GMRES,        }
\DoxyCodeLine{    GMRES,             }
\DoxyCodeLine{    PREC\_BICGSTAB,     }
\DoxyCodeLine{    BICGSTAB           }
\DoxyCodeLine{\};}

\end{DoxyCode}


with \mbox{\hyperlink{}{Krylov\+Solver\+::\+AUTO}} being the default value. The \mbox{\hyperlink{}{Krylov\+Solver\+::\+AUTO}} setting will use iterative refinement when HSS compression is not enabled, and preconditioned GMRES when HSS compression is enabled, see \mbox{\hyperlink{HSS_Preconditioning}{HSS Preconditioning}}. To use the solver as a preconditioner, or a single (approximate) solve, set the solver to \mbox{\hyperlink{}{Krylov\+Solver\+::\+DIRECT}}. When calling \mbox{\hyperlink{}{Sp\+MPIDist\+::solve}}, the right-\/hand side and solution vectors should only point to the local parts!\hypertarget{sparse_example_usage_autotoc_md16}{}\doxysubsection{Reordering}\label{sparse_example_usage_autotoc_md16}
The STRUMPACK sparse solver applies three different matrix orderings
\begin{DoxyItemize}
\item For numerical stability
\item To reduce fill-\/in
\item To reduce the numerical rank of certain blocks when preconditioning These reorderings are all performed when calling 
\begin{DoxyCode}{0}
\DoxyCodeLine{ReturnCode strumpack::StrumpackSparseSolver::reorder( ); }

\end{DoxyCode}

\end{DoxyItemize}\hypertarget{sparse_example_usage_autotoc_md17}{}\doxysubsubsection{Reordering for Numerical Stability}\label{sparse_example_usage_autotoc_md17}
The reordering for numerical stability is performed using MC64 or Combinatorial BLAS. For many matrices, this reordering is not necessary and can safely be disabled! MC64 supports 5 different modes and there is one option to select the Combinatorial BLAS code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{enum class} MatchingJob \{}
\DoxyCodeLine{    NONE,                           }
\DoxyCodeLine{    MAX\_CARDINALITY,                }
\DoxyCodeLine{    MAX\_SMALLEST\_DIAGONAL,          }
\DoxyCodeLine{    MAX\_SMALLEST\_DIAGONAL\_2,        }
\DoxyCodeLine{    MAX\_DIAGONAL\_SUM,               }
\DoxyCodeLine{    MAX\_DIAGONAL\_PRODUCT\_SCALING,   }
\DoxyCodeLine{    COMBBLAS                        }
\DoxyCodeLine{\};}

\end{DoxyCode}


which can be selected via


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} strumpack::SPOptions::set\_matching(MatchingJob job);}
\DoxyCodeLine{MatchingJob strumpack::SPOptions::matching() \textcolor{keyword}{const};}

\end{DoxyCode}


where matching() queries the currently selected strategy (the default is MAX\+\_\+\+DIAGONAL\+\_\+\+PRODUCT\+\_\+\+SCALING maximum product of diagonal values plus row and column scaling). The command line option


\begin{DoxyCode}{0}
\DoxyCodeLine{-\/-\/sp\_matching [0-\/6] }

\end{DoxyCode}


can also be used, where the integers are defined as\+:
\begin{DoxyItemize}
\item 0\+: no reordering for stability, this disables MC64/matching
\item 1\+: MC64(1)\+: currently not supported
\item 2\+: MC64(2)\+: maximize the smallest diagonal value
\item 3\+: MC64(3)\+: maximize the smallest diagonal value, different strategy
\item 4\+: MC64(4)\+: maximize sum of diagonal values
\item 5\+: MC64(5)\+: maximize product of diagonal values and apply row and column scaling
\item 6\+: Combinatorial BLAS\+: approximate weight perfect matching
\end{DoxyItemize}

The MC64 code is sequential, so when using this option in parallel, the graph is first gathered to the root process. The Combinatorial BLAS code can currently only be used in parallel, and only with a square number of processes.\hypertarget{sparse_example_usage_autotoc_md18}{}\doxysubsubsection{Nested Dissection Recording}\label{sparse_example_usage_autotoc_md18}
The STRUMPACK sparse solver supports both (Par)Metis and (PT-\/)Scotch for the matrix reordering. The following functions can set the preferred method or check the currently selected method\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} strumpack::SPOptions::set\_reordering\_method(ReorderingStrategy m);}
\DoxyCodeLine{ReorderingStrategy strumpack::SPOptions::reordering\_method() \textcolor{keyword}{const};}

\end{DoxyCode}


The options for Matrix\+Reordering\+Strategy are


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{enum class} ReorderingStrategy \{}
\DoxyCodeLine{    NATURAL,    }
\DoxyCodeLine{    METIS,      }
\DoxyCodeLine{    PARMETIS,   }
\DoxyCodeLine{    SCOTCH,     }
\DoxyCodeLine{    PTSCOTCH,   }
\DoxyCodeLine{    RCM,        }
\DoxyCodeLine{    GEOMETRIC   }
\DoxyCodeLine{\};}

\end{DoxyCode}


When the solver is an object of Sp, PARMETIS or PTSCOTCH are not supported. When the solver is parallel, either an \mbox{\hyperlink{}{Sp\+MPI}} or \mbox{\hyperlink{}{Sp\+MPIDist}} object, and METIS, SCOTCH or RCM are chosen, then the graph of the complete matrix will be gathered onto the root process and the root process will call the (sequential) Metis, Scotch or RCM reordering routine. For large graphs this might fail due to insufficient memory.

The GEOMETRIC option is only allowed for regular grids. In this case, the dimensions of the grid should be specified in the function


\begin{DoxyCode}{0}
\DoxyCodeLine{ ReturnCode strumpack::StrumpackSparseSolver::reorder(\textcolor{keywordtype}{int}}
\DoxyCodeLine{nx=1, \textcolor{keywordtype}{int} ny=1, \textcolor{keywordtype}{int} nz=1); }

\end{DoxyCode}


For instance for a regular 2d 2000 $×$ 4000 grid, you can call this as sp.\+reorder(2000, 4000). In the general algebraic case, the grid dimensions don’t have to be provided. The reordering method can also be specified via the command line option


\begin{DoxyCode}{0}
\DoxyCodeLine{-\/-\/sp\_reordering\_method [metis|parmetis|scotch|ptscotch|geometric|rcm] }

\end{DoxyCode}
\hypertarget{sparse_example_usage_autotoc_md19}{}\doxysubsection{Setting and Parsing Options}\label{sparse_example_usage_autotoc_md19}
The sparse solver options are stored in an object of class \mbox{\hyperlink{}{SPOptions}}, which can be accessed through\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{strumpack::SPOptions<scalar>\& strumpack::SPOptions(); }

\end{DoxyCode}
 see also Strumpack\+Options.\+hpp for several enumerations.

To get a list of all available options, make sure to pass “int argc, char$\ast$ argv\mbox{[}\mbox{]}” when initializing the \mbox{\hyperlink{}{Strumpack\+Sparse\+Solver}} or when calling \mbox{\hyperlink{}{SPOptions\+::set\+\_\+from\+\_\+command\+\_\+line}} and run the application with --help or -\/h. Some default values listed here are for double precision and might be different when running in single precision.

STRUMPACK sparse solver options\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\# STRUMPACK options:}
\DoxyCodeLine{\#   -\/-\/sp\_maxit int (default 5000)}
\DoxyCodeLine{\#          maximum Krylov iterations}
\DoxyCodeLine{\#   -\/-\/sp\_rel\_tol real\_t (default 1e-\/06)}
\DoxyCodeLine{\#          Krylov relative (preconditioned) residual stopping tolerance}
\DoxyCodeLine{\#   -\/-\/sp\_abs\_tol real\_t (default 1e-\/10)}
\DoxyCodeLine{\#          Krylov absolute (preconditioned) residual stopping tolerance}
\DoxyCodeLine{\#   -\/-\/sp\_Krylov\_solver [auto|direct|refinement|pgmres|gmres|pbicgstab|bicgstab]}
\DoxyCodeLine{\#          default: auto (refinement when no HSS, pgmres (preconditioned) with HSS compression)}
\DoxyCodeLine{\#   -\/-\/sp\_gmres\_restart int (default 30)}
\DoxyCodeLine{\#          gmres restart length}
\DoxyCodeLine{\#   -\/-\/sp\_GramSchmidt\_type [modified|classical]}
\DoxyCodeLine{\#          Gram-\/Schmidt type for GMRES}
\DoxyCodeLine{\#   -\/-\/sp\_reordering\_method [natural|metis|scotch|parmetis|ptscotch|rcm|geometric]}
\DoxyCodeLine{\#          Code for nested dissection.}
\DoxyCodeLine{\#          Geometric only works on regular meshes and you need to provide the sizes.}
\DoxyCodeLine{\#   -\/-\/sp\_nd\_param int (default 8)}
\DoxyCodeLine{\#   -\/-\/sp\_nx int (default 1)}
\DoxyCodeLine{\#   -\/-\/sp\_ny int (default 1)}
\DoxyCodeLine{\#   -\/-\/sp\_nz int (default 1)}
\DoxyCodeLine{\#   -\/-\/sp\_components int (default 1)}
\DoxyCodeLine{\#   -\/-\/sp\_separator\_width int (default 1)}
\DoxyCodeLine{\#   -\/-\/sp\_enable\_METIS\_NodeNDP (default false)}
\DoxyCodeLine{\#          use undocumented Metis routine NodeNDP instead of NodeND}
\DoxyCodeLine{\#   -\/-\/sp\_disable\_METIS\_NodeNDP (default true)}
\DoxyCodeLine{\#          use Metis routine NodeND instead of the undocumented NodeNDP}
\DoxyCodeLine{\#   -\/-\/sp\_enable\_METIS\_NodeND (default true)}
\DoxyCodeLine{\#          use Metis routine NodeND instead of the undocumented NodeNDP}
\DoxyCodeLine{\#   -\/-\/sp\_disable\_METIS\_NodeND (default false)}
\DoxyCodeLine{\#          use undocumented Metis routine NodeNDP instead of NodeND}
\DoxyCodeLine{\#   -\/-\/sp\_enable\_MUMPS\_SYMQAMD (default false)}
\DoxyCodeLine{\#   -\/-\/sp\_disable\_MUMPS\_SYMQAMD (default true)}
\DoxyCodeLine{\#   -\/-\/sp\_enable\_agg\_amalg (default false)}
\DoxyCodeLine{\#   -\/-\/sp\_disable\_agg\_amalg (default true)}
\DoxyCodeLine{\#   -\/-\/sp\_matching int [0-\/6] (default 0)}
\DoxyCodeLine{\#      0 none}
\DoxyCodeLine{\#      1 maximum cardinality ! Doesn't work}
\DoxyCodeLine{\#      2 maximum smallest diagonal value, version 1}
\DoxyCodeLine{\#      3 maximum smallest diagonal value, version 2}
\DoxyCodeLine{\#      4 maximum sum of diagonal values}
\DoxyCodeLine{\#      5 maximum matching with row and column scaling}
\DoxyCodeLine{\#      6 approximate weigthed perfect matching, from CombBLAS}
\DoxyCodeLine{\#   -\/-\/sp\_compression [none|hss|blr|hodlr]}
\DoxyCodeLine{\#          type of rank-\/structured compression to use}
\DoxyCodeLine{\#   -\/-\/sp\_compression\_min\_sep\_size (default 2147483647)}
\DoxyCodeLine{\#          minimum separator size for compression}
\DoxyCodeLine{\#   -\/-\/sp\_compression\_leaf\_size (default 2147483647)}
\DoxyCodeLine{\#          leaf size for rank-\/structured representation}
\DoxyCodeLine{\#   -\/-\/sp\_separator\_ordering\_level (default 1)}
\DoxyCodeLine{\#   -\/-\/sp\_enable\_indirect\_sampling}
\DoxyCodeLine{\#   -\/-\/sp\_disable\_indirect\_sampling}
\DoxyCodeLine{\#   -\/-\/sp\_enable\_replace\_tiny\_pivots}
\DoxyCodeLine{\#   -\/-\/sp\_disable\_replace\_tiny\_pivots}
\DoxyCodeLine{\#   -\/-\/sp\_write\_root\_front}
\DoxyCodeLine{\#   -\/-\/sp\_print\_root\_front\_stats}
\DoxyCodeLine{\#   -\/-\/sp\_enable\_gpu}
\DoxyCodeLine{\#   -\/-\/sp\_disable\_gpu}
\DoxyCodeLine{\#   -\/-\/sp\_cuda\_cutoff (default 500)}
\DoxyCodeLine{\#          CUDA kernel/CUBLAS cutoff size}
\DoxyCodeLine{\#   -\/-\/sp\_cuda\_streams (default 10)}
\DoxyCodeLine{\#          number of CUDA streams}
\DoxyCodeLine{\#   -\/-\/sp\_verbose or -\/v (default true)}
\DoxyCodeLine{\#   -\/-\/sp\_quiet or -\/q (default false)}
\DoxyCodeLine{\#   -\/-\/help or -\/h}

\end{DoxyCode}
 