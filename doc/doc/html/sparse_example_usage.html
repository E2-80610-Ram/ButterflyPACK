<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BUTTERFLYPACK v@PROJECT_VERSION@: Example Usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="../custom-style/my_customdoxygen.css" rel="stylesheet" type="text/css" />
<link href="my_customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname" style="font-family: silom;"><a href="#"><img src="logo.png" style="height:80px"></a>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('sparse_example_usage.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Example Usage </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md9">StrumpackSparseSolver Example</a></li>
<li class="level1"><a href="#autotoc_md11">StrumpackSparseSolverMPIDist Example</a></li>
<li class="level1"><a href="#autotoc_md12">Initializing the Solver Object</a></li>
<li class="level1"><a href="#autotoc_md13">Sparse Matrix Format</a></li>
<li class="level1"><a href="#autotoc_md14">Factorization</a></li>
<li class="level1"><a href="#autotoc_md15">Solve</a></li>
<li class="level1"><a href="#autotoc_md16">Reordering</a><ul><li class="level2"><a href="#autotoc_md17">Reordering for Numerical Stability</a></li>
<li class="level2"><a href="#autotoc_md18">Nested Dissection Recording</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md19">Setting and Parsing Options</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md9"></a>
StrumpackSparseSolver Example</h1>
<p >The following shows the typical way to use a (sequential or multithreaded) STRUMPACK sparse solver:</p>
<div class="image">
<img src="SSSEx.png" alt="" width="75%"/>
</div>
<p ><b>Figure 1</b>: Illustration of a small 5 × 5 sparse matrix with 11 nonzeros and its Compressed Sparse Row (CSR) or Yale format representation. We always use 0-based indexing! Let \(N\) = 5 denote the number of rows. The row_ptr array has \(N\) +1 elements, with element \(i\) denoting the start of row \(i\) in the col_ind and values arrays. Element row_ptr[N] = nnz, i.e., the total number of nonzero elements in the matrix. The values array holds the actual matrix values, ordered by row. The corresponding elements in col_ind give the column indices for each nonzero. There can be explicit zero elements in the matrix. The nonzero values and corresponding column indices need not be sorted by column (within a row).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;StrumpackSparseSolver.hpp&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>strumpack;      <span class="comment">// all strumpack code is in the strumpack namespace,</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">   <span class="keywordtype">int</span> N = ...;                      <span class="comment">// construct an NxN CSR matrix with nnz nonzeros</span></div>
<div class="line">   <span class="keywordtype">int</span>* row_ptr = ...;               <span class="comment">// N+1 integers</span></div>
<div class="line">   <span class="keywordtype">int</span>* col_ind = ...;               <span class="comment">// nnz integers</span></div>
<div class="line">   <span class="keywordtype">double</span>* val = ...;                <span class="comment">// nnz scalars</span></div>
<div class="line">   <span class="keywordtype">double</span>* x = <span class="keyword">new</span> <span class="keywordtype">double</span>[N];        <span class="comment">// will hold the solution vector</span></div>
<div class="line">   <span class="keywordtype">double</span>* b = ...;                  <span class="comment">// set a right-hand side b</span></div>
<div class="line"> </div>
<div class="line">   StrumpackSparseSolver&lt;double&gt; sp;                   <span class="comment">// create solver object</span></div>
<div class="line">   sp.options().set_rel_tol(1e-10);                    <span class="comment">// set options</span></div>
<div class="line">   sp.options().set_gmres_restart(10);                 <span class="comment">// ...</span></div>
<div class="line">   sp.options().set_compression(CompressionType::HSS); <span class="comment">// enable HSS compression, see HSS Preconditioning</span></div>
<div class="line">   sp.options().set_from_command_line(argc, argv);     <span class="comment">// parse command line options</span></div>
<div class="line">   sp.set_csr_matrix(N, row_ptr, col_ind, val);        <span class="comment">// set the matrix (copy)</span></div>
<div class="line">   sp.reorder();                                       <span class="comment">// reorder matrix</span></div>
<div class="line">   sp.factor();                                        <span class="comment">// numerical factorization</span></div>
<div class="line">   sp.solve(b, x);                                     <span class="comment">// solve Ax=b</span></div>
<div class="line">   ... <span class="comment">// check residual/error and cleanup</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >The main steps are: create solver object, set options (parse options from the command line), set matrix, reorder, factor and finally solve. The matrix should be in the Compressed Sparse Row (CSR) format, also called Yale format, with 0 based indices. Figure 1 illustrates the CSR format. In the basic scenario, it is not necessary to explicitly call reorder and factor, since trying to solve with a StrumpackSparseSolver object that is not factored yet, will internally call the factor routine, which will call reorder if necessary.</p>
<p >The above code should be linked with -lstrumpack and with the Metis, ParMetis, Scotch, PT-Scotch, BLAS, LAPACK, and ScaLAPACK libraries.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
StrumpackSparseSolverMPIDist Example</h1>
<p >Finally, we illustrate the usage of <a class="el" href="">StrumpackSparseSolverMPIDist&lt;scalar,integer=int&gt; </a> solver. This interface takes a block-row distributed compressed sparse row matrix as input. This matrix format is illustrated in Figure 2 (below).</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #include &quot;StrumpackSparseSolverMPI.hpp&quot;</span></div>
<div class="line"> <span class="keyword">using namespace </span>strumpack;</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[ ]) {</div>
<div class="line">     <span class="keywordtype">int</span> thread_level, rank, P;</div>
<div class="line">     MPI_Init_thread(&amp;argc, &amp;argv, MPI_THREAD_FUNNELED, &amp;thread_level);</div>
<div class="line">     MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</div>
<div class="line">     MPI_Comm_size(MPI_COMM_WORLD, &amp;P);</div>
<div class="line">     {</div>
<div class="line">         <span class="comment">// define a block-row distributed CSR matrix</span></div>
<div class="line">         <span class="keywordtype">int</span>* dist = <span class="keyword">new</span> <span class="keywordtype">int</span>[P];</div>
<div class="line">         <span class="comment">// set dist such that processor p owns rows [dist[p], dist[p+1]) of the sparse matrix</span></div>
<div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p=0; p&lt;P; p++) dist[p] = .. ;</div>
<div class="line">         <span class="comment">// local_n is the number of rows of the input matrix assigned to me</span></div>
<div class="line">         <span class="keywordtype">int</span> local_n   = dist[rank+1] - dist[rank];</div>
<div class="line">         <span class="keywordtype">int</span>* row_ptr  = <span class="keyword">new</span> <span class="keywordtype">int</span>[local_n+1];</div>
<div class="line">         .. <span class="comment">// set the sparse matrix row pointers in row_ptr</span></div>
<div class="line">         <span class="keywordtype">int</span> local_nnz = row_ptr[local_n+1] - row_ptr[0];</div>
<div class="line">         <span class="keywordtype">int</span>* col_ind  = <span class="keyword">new</span> <span class="keywordtype">int</span>[local_nnz];</div>
<div class="line">         .. <span class="comment">// set the sparse matrix column indices in col_ind</span></div>
<div class="line">         <span class="keywordtype">double</span>* val   = <span class="keyword">new</span> <span class="keywordtype">double</span>[local_nnz];</div>
<div class="line">         .. <span class="comment">// set the matrix nonzero value in val</span></div>
<div class="line">         <span class="keywordtype">double</span>* x = <span class="keyword">new</span> <span class="keywordtype">double</span>[local_n];             <span class="comment">// local part of solution</span></div>
<div class="line">         <span class="keywordtype">double</span>* b = <span class="keyword">new</span> <span class="keywordtype">double</span>[local_n];             <span class="comment">// local part of rhs</span></div>
<div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;local_n; i++) b[i] = ..;     <span class="comment">// set the rhs</span></div>
<div class="line"> </div>
<div class="line">         strumpack::StrumpackSparseSolverMPIDist&lt;double&gt; sp(MPI_COMM_WORLD);</div>
<div class="line">         sp.options().set_reordering_method(ReorderingStrategy::PARMETIS);</div>
<div class="line">         sp.options().set_from_command_line(argc, argv);</div>
<div class="line">         sp.set_distributed_csr_matrix(local_n, row_ptr, col_ind, val, dist);</div>
<div class="line">         sp.solve(b, x);</div>
<div class="line">         ... <span class="comment">// check residual/error, cleanup</span></div>
<div class="line">     }</div>
<div class="line">     Cblacs_exit(1);</div>
<div class="line">     MPI_Finalize();</div>
<div class="line">}</div>
</div><!-- fragment --><div class="image">
<img src="SSSMPIDistEx.png" alt="" width="75%"/>
</div>
<p ><b>Figure 2</b>: Illustration of a small 5×5 sparse matrix with 11 nonzeros and its block-row distributed compressed sparse row representation. We always use 0-based indexing! Process P0 owns row 0, process P1 has rows 1 and 2 and process P2 has rows 3 and 4. This distribution of rows over the processes is represented by the dist array. Process p owns rows [dist[p],dist[p+1]). If N = 5 is the number of rows in the entire matrix and P is the total number of processes, then dist[P]=N. The (same) dist array is stored on every process. Each process holds a CSR representation of only its local rows of the matrix, see Figure 1.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Initializing the Solver Object</h1>
<p >Let</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> strumpack::StrumpackSparseSolver&lt;scalar,integer&gt; Sp;</div>
<div class="line"><span class="keyword">typedef</span> strumpack::StrumpackSparseSolverMPI&lt;scalar,integer&gt; SpMPI;</div>
<div class="line"><span class="keyword">typedef</span> strumpack::StrumpackSparseSolverMPIDist&lt;scalar,integer&gt; SpMPIDist;</div>
</div><!-- fragment --><p >Each of the solver classes has two constructors:</p>
<div class="fragment"><div class="line">strumpack::StrumpackSparseSolver(<span class="keywordtype">bool</span> verbose=<span class="keyword">true</span>, <span class="keywordtype">bool</span> root=<span class="keyword">true</span>);</div>
<div class="line">strumpack::StrumpackSparseSolver(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[], <span class="keywordtype">bool</span> verbose=<span class="keyword">true</span>, <span class="keywordtype">bool</span> root=<span class="keyword">true</span>);</div>
</div><!-- fragment --><div class="fragment"><div class="line">strumpack::StrumpackSparseSolverMPIDist(MPI_Comm comm, <span class="keywordtype">bool</span> verbose=<span class="keyword">true</span>);</div>
<div class="line">strumpack::StrumpackSparseSolverMPIDist(MPI_Comm comm, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[], <span class="keywordtype">bool</span> verbose=<span class="keyword">true</span>);</div>
</div><!-- fragment --><div class="fragment"><div class="line">strumpack::StrumpackSparseSolverMPIDist(MPI_Comm comm, <span class="keywordtype">bool</span> verbose=<span class="keyword">true</span>);</div>
<div class="line">strumpack::StrumpackSparseSolverMPIDist(MPI_Comm comm, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[], <span class="keywordtype">bool</span> verbose=<span class="keyword">true</span>); </div>
</div><!-- fragment --><p >where argc and argv contain the command line options and the verbose option can be set to false to suppress output of the solver. Note that since <a class="el" href="">SpMPIDist</a> is a subclass of <a class="el" href="">SpMPI</a>, which is a subclass of <a class="el" href="">Sp</a>, all public members of <a class="el" href="">Sp</a> are also members of <a class="el" href="">SpMPI</a> and <a class="el" href="">SpMPIDist</a>. The public interface to the <a class="el" href="">SpMPI</a> class is exactly the same as that for the <a class="el" href="">Sp</a> class.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Sparse Matrix Format</h1>
<p >The sparse matrix should be specified in compressed sparse row format [8]:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> strumpack::StrumpackSparseSolver::set_csr_matrix(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span>* row_ptr, <span class="keywordtype">int</span>* col_ind, scalar* values, <span class="keywordtype">bool</span> symmetric_pattern=<span class="keyword">false</span>);</div>
</div><!-- fragment --><p >Internally, the matrix is copied, so it will not be modified. Previous versions of STRUMPACK also supported the CSC format, but this is now deprecated. If the sparsity pattern of the matrix is symmetric (the values do not have to be symmetric), then you can set symmetric_pattern=true. This saves some work in the setup phase of the solver.</p>
<p >For the <a class="el" href="">SpMPIDist</a> solver the input is a block-row distributed compressed sparse row matrix (as illustrated in the example above):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> strumpack::StrumpackSparseSolverMPIDist::set_distributed_csr_matrix (integer local_rows, integer* row_ptr, integer* col_ind, scalar* values, integer* dist, <span class="keywordtype">bool</span> symmetric_pattern=<span class="keyword">false</span>);</div>
</div><!-- fragment --><p >Alternatively, you can also specify a sequential CSR matrix to the <a class="el" href="">SpMPIDist</a> solver:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> strumpack::StrumpackSparseSolverMPIDist::set_csr_matrix (integer N, integer* row_ptr, integer* col_ind, scalar* values, <span class="keywordtype">bool</span> symmetric_pattern=<span class="keyword">false</span>);</div>
</div><!-- fragment --><p >For this routine, the matrix only needs to be specified completely on the root process. Other processes can pass NULL for the arrays.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Factorization</h1>
<p >Compute the factorization by calling</p>
<div class="fragment"><div class="line">ReturnCode strumpack::StrumpackSparseSolver::factor();</div>
</div><!-- fragment --><p >where the possible return values are the same as for <a class="el" href="">Sp::reorder()</a>. If <a class="el" href="">Sp::reorder() </a> was not called already, it is called automatically. When compression is not enabled, this will compute an exact LU factorization of the (permuted) sparse input matrix. If HSS/HODLR/BLR compression is enabled (for instance with <a class="el" href="">SPOptions::set_compression()</a> or --sp_compression BLR, see <a class="el" href="prec.html">Preconditioning Preconditioning</a>), the factorization is only approximate.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Solve</h1>
<p >Solve the linear system \(Ax = b\) by calling</p>
<div class="fragment"><div class="line">ReturnCode strumpack::StrumpackSparseSolver::solve(scalar* b, scalar* x, <span class="keywordtype">bool</span> use_initial_guess=<span class="keyword">false</span>);</div>
</div><!-- fragment --><p >By default (bool use_initial_guess=false) the input in x is ignored. If bool use_initial_guess=true, x is used as initial guess for the iterative solver (if an iterative solver is used, for instance iterative refinement or GMRES). If the <a class="el" href="">Sp::factor()</a> was not called, it is called automatically. The return values are the same as for <a class="el" href="">Sp::reorder()</a>.</p>
<p >The iterative solver can be chosen through:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> strumpack::SPOptions::set_Krylov_solver(strumpack::KrylovSolver s);</div>
</div><!-- fragment --><p >where <a class="el" href="">KrylovSolver</a> can take the following values:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> KrylovSolver {</div>
<div class="line">    AUTO,              </div>
<div class="line">    DIRECT,            </div>
<div class="line">    REFINE,            </div>
<div class="line">    PREC_GMRES,        </div>
<div class="line">    GMRES,             </div>
<div class="line">    PREC_BICGSTAB,     </div>
<div class="line">    BICGSTAB           </div>
<div class="line">};</div>
</div><!-- fragment --><p >with <a class="el" href="">KrylovSolver::AUTO</a> being the default value. The <a class="el" href="">KrylovSolver::AUTO</a> setting will use iterative refinement when HSS compression is not enabled, and preconditioned GMRES when HSS compression is enabled, see <a class="el" href="HSS_Preconditioning.html">HSS Preconditioning</a>. To use the solver as a preconditioner, or a single (approximate) solve, set the solver to <a class="el" href="">KrylovSolver::DIRECT</a>. When calling <a class="el" href="">SpMPIDist::solve</a>, the right-hand side and solution vectors should only point to the local parts!</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Reordering</h1>
<p >The STRUMPACK sparse solver applies three different matrix orderings</p><ul>
<li>For numerical stability</li>
<li>To reduce fill-in</li>
<li>To reduce the numerical rank of certain blocks when preconditioning These reorderings are all performed when calling <div class="fragment"><div class="line">ReturnCode strumpack::StrumpackSparseSolver::reorder( ); </div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md17"></a>
Reordering for Numerical Stability</h2>
<p >The reordering for numerical stability is performed using MC64 or Combinatorial BLAS. For many matrices, this reordering is not necessary and can safely be disabled! MC64 supports 5 different modes and there is one option to select the Combinatorial BLAS code:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> MatchingJob {</div>
<div class="line">    NONE,                           </div>
<div class="line">    MAX_CARDINALITY,                </div>
<div class="line">    MAX_SMALLEST_DIAGONAL,          </div>
<div class="line">    MAX_SMALLEST_DIAGONAL_2,        </div>
<div class="line">    MAX_DIAGONAL_SUM,               </div>
<div class="line">    MAX_DIAGONAL_PRODUCT_SCALING,   </div>
<div class="line">    COMBBLAS                        </div>
<div class="line">};</div>
</div><!-- fragment --><p >which can be selected via</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> strumpack::SPOptions::set_matching(MatchingJob job);</div>
<div class="line">MatchingJob strumpack::SPOptions::matching() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p >where matching() queries the currently selected strategy (the default is MAX_DIAGONAL_PRODUCT_SCALING maximum product of diagonal values plus row and column scaling). The command line option</p>
<div class="fragment"><div class="line">--sp_matching [0-6] </div>
</div><!-- fragment --><p >can also be used, where the integers are defined as:</p><ul>
<li>0: no reordering for stability, this disables MC64/matching</li>
<li>1: MC64(1): currently not supported</li>
<li>2: MC64(2): maximize the smallest diagonal value</li>
<li>3: MC64(3): maximize the smallest diagonal value, different strategy</li>
<li>4: MC64(4): maximize sum of diagonal values</li>
<li>5: MC64(5): maximize product of diagonal values and apply row and column scaling</li>
<li>6: Combinatorial BLAS: approximate weight perfect matching</li>
</ul>
<p >The MC64 code is sequential, so when using this option in parallel, the graph is first gathered to the root process. The Combinatorial BLAS code can currently only be used in parallel, and only with a square number of processes.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Nested Dissection Recording</h2>
<p >The STRUMPACK sparse solver supports both (Par)Metis and (PT-)Scotch for the matrix reordering. The following functions can set the preferred method or check the currently selected method:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> strumpack::SPOptions::set_reordering_method(ReorderingStrategy m);</div>
<div class="line">ReorderingStrategy strumpack::SPOptions::reordering_method() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p >The options for MatrixReorderingStrategy are</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> ReorderingStrategy {</div>
<div class="line">    NATURAL,    </div>
<div class="line">    METIS,      </div>
<div class="line">    PARMETIS,   </div>
<div class="line">    SCOTCH,     </div>
<div class="line">    PTSCOTCH,   </div>
<div class="line">    RCM,        </div>
<div class="line">    GEOMETRIC   </div>
<div class="line">};</div>
</div><!-- fragment --><p >When the solver is an object of Sp, PARMETIS or PTSCOTCH are not supported. When the solver is parallel, either an <a class="el" href="">SpMPI</a> or <a class="el" href="">SpMPIDist</a> object, and METIS, SCOTCH or RCM are chosen, then the graph of the complete matrix will be gathered onto the root process and the root process will call the (sequential) Metis, Scotch or RCM reordering routine. For large graphs this might fail due to insufficient memory.</p>
<p >The GEOMETRIC option is only allowed for regular grids. In this case, the dimensions of the grid should be specified in the function</p>
<div class="fragment"><div class="line"> ReturnCode strumpack::StrumpackSparseSolver::reorder(<span class="keywordtype">int</span></div>
<div class="line">nx=1, <span class="keywordtype">int</span> ny=1, <span class="keywordtype">int</span> nz=1); </div>
</div><!-- fragment --><p >For instance for a regular 2d 2000 \(×\) 4000 grid, you can call this as sp.reorder(2000, 4000). In the general algebraic case, the grid dimensions don’t have to be provided. The reordering method can also be specified via the command line option</p>
<div class="fragment"><div class="line">--sp_reordering_method [metis|parmetis|scotch|ptscotch|geometric|rcm] </div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md19"></a>
Setting and Parsing Options</h1>
<p >The sparse solver options are stored in an object of class <a class="el" href="">SPOptions</a>, which can be accessed through: </p><div class="fragment"><div class="line">strumpack::SPOptions&lt;scalar&gt;&amp; strumpack::SPOptions(); </div>
</div><!-- fragment --><p> see also StrumpackOptions.hpp for several enumerations.</p>
<p >To get a list of all available options, make sure to pass “int argc, char* argv[]” when initializing the <a class="el" href="">StrumpackSparseSolver</a> or when calling <a class="el" href="">SPOptions::set_from_command_line</a> and run the application with &ndash;help or -h. Some default values listed here are for double precision and might be different when running in single precision.</p>
<p >STRUMPACK sparse solver options: </p><div class="fragment"><div class="line"># STRUMPACK options:</div>
<div class="line">#   --sp_maxit int (default 5000)</div>
<div class="line">#          maximum Krylov iterations</div>
<div class="line">#   --sp_rel_tol real_t (default 1e-06)</div>
<div class="line">#          Krylov relative (preconditioned) residual stopping tolerance</div>
<div class="line">#   --sp_abs_tol real_t (default 1e-10)</div>
<div class="line">#          Krylov absolute (preconditioned) residual stopping tolerance</div>
<div class="line">#   --sp_Krylov_solver [auto|direct|refinement|pgmres|gmres|pbicgstab|bicgstab]</div>
<div class="line">#          default: auto (refinement when no HSS, pgmres (preconditioned) with HSS compression)</div>
<div class="line">#   --sp_gmres_restart int (default 30)</div>
<div class="line">#          gmres restart length</div>
<div class="line">#   --sp_GramSchmidt_type [modified|classical]</div>
<div class="line">#          Gram-Schmidt type for GMRES</div>
<div class="line">#   --sp_reordering_method [natural|metis|scotch|parmetis|ptscotch|rcm|geometric]</div>
<div class="line">#          Code for nested dissection.</div>
<div class="line">#          Geometric only works on regular meshes and you need to provide the sizes.</div>
<div class="line">#   --sp_nd_param int (default 8)</div>
<div class="line">#   --sp_nx int (default 1)</div>
<div class="line">#   --sp_ny int (default 1)</div>
<div class="line">#   --sp_nz int (default 1)</div>
<div class="line">#   --sp_components int (default 1)</div>
<div class="line">#   --sp_separator_width int (default 1)</div>
<div class="line">#   --sp_enable_METIS_NodeNDP (default false)</div>
<div class="line">#          use undocumented Metis routine NodeNDP instead of NodeND</div>
<div class="line">#   --sp_disable_METIS_NodeNDP (default true)</div>
<div class="line">#          use Metis routine NodeND instead of the undocumented NodeNDP</div>
<div class="line">#   --sp_enable_METIS_NodeND (default true)</div>
<div class="line">#          use Metis routine NodeND instead of the undocumented NodeNDP</div>
<div class="line">#   --sp_disable_METIS_NodeND (default false)</div>
<div class="line">#          use undocumented Metis routine NodeNDP instead of NodeND</div>
<div class="line">#   --sp_enable_MUMPS_SYMQAMD (default false)</div>
<div class="line">#   --sp_disable_MUMPS_SYMQAMD (default true)</div>
<div class="line">#   --sp_enable_agg_amalg (default false)</div>
<div class="line">#   --sp_disable_agg_amalg (default true)</div>
<div class="line">#   --sp_matching int [0-6] (default 0)</div>
<div class="line">#      0 none</div>
<div class="line">#      1 maximum cardinality ! Doesn&#39;t work</div>
<div class="line">#      2 maximum smallest diagonal value, version 1</div>
<div class="line">#      3 maximum smallest diagonal value, version 2</div>
<div class="line">#      4 maximum sum of diagonal values</div>
<div class="line">#      5 maximum matching with row and column scaling</div>
<div class="line">#      6 approximate weigthed perfect matching, from CombBLAS</div>
<div class="line">#   --sp_compression [none|hss|blr|hodlr]</div>
<div class="line">#          type of rank-structured compression to use</div>
<div class="line">#   --sp_compression_min_sep_size (default 2147483647)</div>
<div class="line">#          minimum separator size for compression</div>
<div class="line">#   --sp_compression_leaf_size (default 2147483647)</div>
<div class="line">#          leaf size for rank-structured representation</div>
<div class="line">#   --sp_separator_ordering_level (default 1)</div>
<div class="line">#   --sp_enable_indirect_sampling</div>
<div class="line">#   --sp_disable_indirect_sampling</div>
<div class="line">#   --sp_enable_replace_tiny_pivots</div>
<div class="line">#   --sp_disable_replace_tiny_pivots</div>
<div class="line">#   --sp_write_root_front</div>
<div class="line">#   --sp_print_root_front_stats</div>
<div class="line">#   --sp_enable_gpu</div>
<div class="line">#   --sp_disable_gpu</div>
<div class="line">#   --sp_cuda_cutoff (default 500)</div>
<div class="line">#          CUDA kernel/CUBLAS cutoff size</div>
<div class="line">#   --sp_cuda_streams (default 10)</div>
<div class="line">#          number of CUDA streams</div>
<div class="line">#   --sp_verbose or -v (default true)</div>
<div class="line">#   --sp_quiet or -q (default false)</div>
<div class="line">#   --help or -h</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="sparse.html">Sparse Direct Solver</a></li>
    <li><a href="https://github.com/pghysels/STRUMPACK">STRUMPACK on Github</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
